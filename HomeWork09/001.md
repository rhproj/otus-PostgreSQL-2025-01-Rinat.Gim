##  Полнотекстовый поиск 
```sql
hwdb=# CREATE TABLE documents (
    title    varchar(64),
    metadata jsonb,
    contents text
);
CREATE TABLE

hwdb=# INSERT INTO documents
    (title, metadata, contents)
VALUES
    ( 'Document 1',
      '{"author": "John",  "tags": ["legal", "real estate"]}',
 ...
 ...
     ( 'Document 7',
      '{"author": "John",  "tags": ["technology", "innovation"]}',
      'Tech innovations are changing the world.' );
```
Создал таблицу для задания на полнотекстовый поиск, заполнил данными.
Получается 3 текстовых  типа в таблице:
`title` - заголовок документа
`metadata` - метаданные в формате JSONB (автор, теги)
`contents` - содержимое документа

```sql
hwdb=# SELECT * FROM documents WHERE metadata @> '{"author": "John"}';

   title    |                         metadata                         |                  contents                   
------------+----------------------------------------------------------+---------------------------------------------
 Document 1 | {"tags": ["legal", "real estate"], "author": "John"}     | This is a legal document about real estate.
 Document 7 | {"tags": ["technology", "innovation"], "author": "John"} | Tech innovations are changing the world.
(2 rows)
```
Здесь, оператором `@>` проверил, содержит ли JSON-объект указанный подобъект.
Т.о. нашел все документы, созданные автором "John". 

```sql
hwdb=# CREATE INDEX idx_documents_metadata ON documents USING GIN (metadata);
CREATE INDEX
```
Создал Generalized Inverted Index для оптимизации поиска по составным типам данных (JSON). 

Из-за того что таблица небольшая отключю последовательное сканирование, чтоб заставить postgres использоваь индекс
```sql
hwdb=# SET enable_seqscan = OFF;
```

```sql
hwdb=# EXPLAIN SELECT * FROM documents WHERE metadata @> '{"author": "John"}';
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Bitmap Heap Scan on documents  (cost=12.00..16.01 rows=1 width=210)
   Recheck Cond: (metadata @> '{"author": "John"}'::jsonb)
   ->  Bitmap Index Scan on idx_documents_metadata  (cost=0.00..12.00 rows=1 width=0)
         Index Cond: (metadata @> '{"author": "John"}'::jsonb)
(4 rows)
```
Изучаю план выполнения запроса
 *Bitmap Index Scan* - PostgreSQL сначала сканирует индекс, чтобы найти все строки, удовлетворяющие условию metadata @> '{"author": "John"}'. Результатом этого сканирования является битовая карта, где каждый бит соответствует строке в таблице.
*Bitmap Heap Scan* - Затем PostgreSQL использует эту битовую карту для доступа только к тем строкам таблицы, которые соответствуют условию. 
Включение `Recheck Cond` означает что Bitmap Heap Scan перепроверяет условие `metadata @> '{"author": "John"}'` для каждой строки-кандидата, такое происходит при использовании оператора **@>**
**Итог:**
1. Планировщик оценивает, что запрос вернёт примерно 1 строку (`rows=1`).
2. Стоимость выполнения запроса оценивается в 16.01 условных единиц, что относительно низко.


```sql
hwdb=# SELECT * FROM documents WHERE metadata->'tags' ? 'legal';
   title    |                       metadata                       |                  contents                   
------------+------------------------------------------------------+---------------------------------------------
 Document 1 | {"tags": ["legal", "real estate"], "author": "John"} | This is a legal document about real estate.
 Document 2 | {"tags": ["finance", "legal"], "author": "Jane"}     | Financial statements should be verified.
 Document 5 | {"tags": ["legal", "contracts"], "author": "Bob"}    | Contracts are binding legal documents.
 Document 6 | {"tags": ["legal", "family law"], "author": "Eve"}   | Family law addresses diverse issues.
(4 rows)
```
Забываю что у меня выключен seqscan, этот запрос выполнялся секунуд.  Оператор `?` проверяет, содержит ли JSON-массив указанное значение. ".

Смотрю план запроса при включенном и отключенном seqscan
```sql
hwdb=# SET enable_seqscan = ON;
SET
hwdb=# EXPLAIN SELECT * FROM documents WHERE metadata->'tags' ? 'legal';
                        QUERY PLAN                         
-----------------------------------------------------------
 Seq Scan on documents  (cost=0.00..1.10 rows=1 width=116)
   Filter: ((metadata -> 'tags'::text) ? 'legal'::text)
(2 rows)

hwdb=# SET enable_seqscan = OFF;
SET
hwdb=# EXPLAIN SELECT * FROM documents WHERE metadata->'tags' ? 'legal';
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Seq Scan on documents  (cost=10000000000.00..10000000001.10 rows=1 width=116)
   Filter: ((metadata -> 'tags'::text) ? 'legal'::text)
 JIT:
   Functions: 2
   Options: Inlining true, Optimization true, Expressions true, Deforming true
(5 rows)
```
вижу что в обоих случаях выполняется последовательное сканирование, но ввиду отсутсвия подходящего индекса
PostgreSQL не полностью запрещает  использование seqscan, а делает его дорогим с точки зрения оценки стоимости.


```sql
hwdb=# CREATE INDEX idx_documents_metadata_tags ON documents USING gin((metadata->'tags'));
CREATE INDEX
```
Добавил индекс для тегов

```sql
hwdb=# SET enable_seqscan = OFF;
SET
hwdb=# ANALYZE documents;
ANALYZE
hwdb=# EXPLAIN SELECT * FROM documents WHERE metadata->'tags' ? 'legal';
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Bitmap Heap Scan on documents  (cost=8.00..12.02 rows=1 width=116)
   Recheck Cond: ((metadata -> 'tags'::text) ? 'legal'::text)
   ->  Bitmap Index Scan on idx_documents_metadata_tags  (cost=0.00..8.00 rows=1 width=0)
         Index Cond: ((metadata -> 'tags'::text) ? 'legal'::text)
(4 rows)
```
План показывает, что стоимость использования индекса (cost=8.00..12.02)  выше, чем стоимость последовательного сканирования (cost=0.00..1.10), предполагаю, что это напрямую связано с размером таблицы.

###### Сравнение поска с Like и Полнотекстового поиска
```sql
hwdb=# INSERT INTO documents (title, metadata, contents)
VALUES
    ('Documentation Guide', 
     '{"author": "Maria", "tags": ["technical", "guide"]}',
     'This comprehensive documentation covers all aspects of the system.'),
    
    ('DOCUMENTS Storage', 
     '{"author": "Alex", "tags": ["storage", "management"]}',
     'All DOCUMENTS must be properly stored according to the retention policy.'),
    
    ('Document Processing', 
     '{"author": "Elena", "tags": ["workflow", "processing"]}',
     'The document processing workflow includes several verification steps.'),
    
    ('Documenting Procedures', 
     '{"author": "Carlos", "tags": ["procedures", "compliance"]}',
     'Documenting your procedures is essential for regulatory compliance.'),
    
    ('Doc Management', 
     '{"author": "Sam", "tags": ["management", "organization"]}',
     'Our doc management system simplifies organization of all your files.'),
    
    ('Документация API', 
     '{"author": "Ivan", "tags": ["api", "reference"]}',
     'Эта документация API содержит все необходимые сведения для разработчиков.'),
    
    ('Misspelled Documennt', 
     '{"author": "Typo King", "tags": ["errors", "typos"]}',
     'This documennt contains a deliberate typo in the word document.');
INSERT 0 7
```
Добавил ещё строк для сравнения разного вида посков

```sql
hwdb=# SELECT title, contents FROM documents WHERE contents LIKE '%document%';
        title         |                               contents                                
----------------------+-----------------------------------------------------------------------
 Document 1           | This is a legal document about real estate.
 Document 5           | Contracts are binding legal documents.
 Documentation Guide  | This comprehensive documentation covers all aspects of the system.
 Document Processing  | The document processing workflow includes several verification steps.
 Misspelled Documennt | This documennt contains a deliberate typo in the word document.
(5 rows)
```
Выполни простой поиск по шаблону, который нашел записи , содержащие слово "document". Недостатки:
- Медленно работает на больших объёмах данных
- Требует точного совпадения (с учётом регистра)
Для учета разных  словоформ (типа документы, документация и регистр) - можно использовать `ILIKE`


```sql
CREATE INDEX idx_documents_contents ON documents USING GIN(to_tsvector('english', contents));
SELECT * FROM documents WHERE to_tsvector('english', contents) @@ 'document';
```
Создал GIN-индекс на основе функции `to_tsvector`, которая преобразует текст в специальный формат для полнотекстового поиска с указанной культурой.
Используем оператор `@@` для поиска документов, содержащих слово "document" или его формы

Функция `to_tsvector` разбивает текст на лексемы, удаляет стоп-слова и приводит слова к их основной форме.

```sql
hwdb=# SELECT title, contents FROM documents WHERE to_tsvector('english', contents) @@ to_tsquery('english', 'document');
         title          |                                 contents                                 
------------------------+--------------------------------------------------------------------------
 Document 1             | This is a legal document about real estate.
 Document 5             | Contracts are binding legal documents.
 Documentation Guide    | This comprehensive documentation covers all aspects of the system.
 DOCUMENTS Storage      | All DOCUMENTS must be properly stored according to the retention policy.
 Document Processing    | The document processing workflow includes several verification steps.
 Documenting Procedures | Documenting your procedures is essential for regulatory compliance.
 Misspelled Documennt   | This documennt contains a deliberate typo in the word document.
(7 rows)
```
Выполнил полнотекстовый поиск: 
Запрос нашел:
- Все формы слова "document" (document, documents, documentation, documenting)
- Независимо от регистра (Document, DOCUMENTS)
- Не найдет опечатки ("documennt") и слова на других языках ("документация")
Такой же результат выдал ILIKE но, на больших массивах данных он был бы не эффективен.

```sql
hwdb=# EXPLAIN SELECT * FROM documents WHERE to_tsvector('english', contents) @@ 'document';
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Bitmap Heap Scan on documents  (cost=12.02..16.54 rows=2 width=116)
   Recheck Cond: (to_tsvector('english'::regconfig, contents) @@ '''document'''::tsquery)
   ->  Bitmap Index Scan on idx_documents_contents  (cost=0.00..12.02 rows=2 width=0)
         Index Cond: (to_tsvector('english'::regconfig, contents) @@ '''document'''::tsquery)
(4 rows)
```
План выполнения и использованием индекса.  
Опять же, если включить возможность послед-го сканирования, postgres предпочтет его для небольшого набора данных, он будет работать быстрее: 
```sql
hwdb=# SET enable_seqscan = on;
SET
hwdb=# EXPLAIN SELECT * FROM documents WHERE to_tsvector('english', contents) @@ 'document';
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Seq Scan on documents  (cost=0.00..2.84 rows=2 width=116)
   Filter: (to_tsvector('english'::regconfig, contents) @@ '''document'''::tsquery)
(2 rows)
```